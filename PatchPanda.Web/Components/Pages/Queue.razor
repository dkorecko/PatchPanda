@page "/queue"

@inject JobRegistry _jobRegistry
@inject ILogger<Queue> _logger
@implements IDisposable

<h3>Update Queue</h3>

<p>This page shows queued and processing jobs.</p>

@if (items is null)
{
    <div class="spinner-grow" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
}
else if (items.Count == 0)
{
    <p>No queued or processing jobs.</p>
}
else
{
    <table class="table">
        <thead>
            <tr>
                <th>Type</th>
                <th>Container Id</th>
                <th>Target Version</th>
                <th>Status</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var it in items)
            {
                <tr>
                    <td>@it.Kind</td>
                    <td>
                        @if (it is PendingUpdateJob uj)
                        {
                            @uj.ContainerId
                        }
                        else
                        {
                            <span>-</span>
                        }
                    </td>
                    <td>
                        @if (it is PendingUpdateJob pu)
                        {
                            @pu.TargetVersionNumber @(" (" + pu.TargetVersionId + ")")
                        } else
                        {
                            <span>-</span>
                        }
                    </td>
                    <td>
                        @if (it.IsProcessing)
                        {
                            <span class="badge text-bg-primary ms-1">
                                <span class="spinner-border spinner-border-sm" role="status" aria-label="Processing" style="width: 0.75rem; height: 0.75rem; border-width: 0.1em;"></span>
                                Processing
                            </span>
                        }
                        else
                        {
                            <span class="badge text-bg-secondary ms-1">
                                <span class="material-symbols-outlined" aria-hidden="true">schedule</span>
                                Queued
                            </span>
                        }
                    </td>
                    <td>
                        @if (!it.IsProcessing)
                        {
                            <button class="btn btn-sm btn-outline-danger" @onclick="() => Cancel(it.Sequence)">Cancel</button>
                        }
                    </td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private List<PendingUpdate>? items;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
            return;

        await LoadSnapshot();
        StartPolling();
    }

    private Task LoadSnapshot()
    {
        try {
            var snapshot = _jobRegistry.GetSnapshot();
            items = snapshot
                .OrderByDescending(i => i.IsProcessing)
                .ThenBy(i => i.Sequence)
                .ToList();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error loading update queue snapshot");
        }

        return Task.CompletedTask;
    }

    private System.Timers.Timer? _pollTimer;

    private void StartPolling()
    {
        if (_pollTimer is not null)
            return;

        _pollTimer = new System.Timers.Timer(1000);
        _pollTimer.Elapsed += async (_, __) => await CheckForUpdates();
        _pollTimer.AutoReset = true;
        _pollTimer.Start();
    }

    private async Task CheckForUpdates()
    {
        await InvokeAsync(LoadSnapshot);
    }

    private async Task Cancel(long sequence)
    {
        var removed = _jobRegistry.TryRemove(sequence);

        if (removed)
        {
            await LoadSnapshot();
        }
    }

    public void Dispose()
    {
        if (_pollTimer is not null)
        {
            _pollTimer.Stop();
            _pollTimer.Dispose();
            _pollTimer = null;
        }
    }
}
