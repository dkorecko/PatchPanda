@page "/versions/{ContainerId:int}"
@inject IDbContextFactory<DataContext> _dbContextFactory
@inject IVersionService _versionService
@inject UpdateService _updateService
@inject JobRegistry _jobRegistry
@implements IDisposable

<PageTitle>Versions - @Constants.APP_NAME</PageTitle>

@if(_app is null)
{
    <div class="spinner-grow" role="status">
    </div>
}
else
{
    <PageTitle>@_app.Name versions - @Constants.APP_NAME</PageTitle>
    <h4>@_app.Name</h4>
    @if(_app.MultiContainerApp is not null)
    {
        <b>All affected apps:</b> @string.Join(", ", _app.MultiContainerApp.Containers.Select(x => x.Name))
    }
    <p>
        Current Version: @(_app.Version ?? "Missing")
    </p>
    <p>
        Newer Versions:
    </p>
    if (!_app.NewerVersions.Any())
    {
        <div class="alert alert-success" role="alert">
            This app is up to date!
        </div>
    }
    else
    {
        var processingUpdate = _jobRegistry.GetProcessingUpdateForContainer(_app.Id);

        <ul>
            @foreach(var version in _app.NewerVersions)
            {
                <li class='@(version.Ignored ? "text-body-tertiary" : string.Empty)'>
                    <div>
                        <b><u>@version.Name</u></b>
                        <b>(@version.VersionNumber)</b>
                        @if(version.Prerelease)
                        {
                            <b class="ms-2">[PRERELEASE]</b>
                        }
                        @if(version.Breaking)
                        {
                            <b class="ms-2">[BREAKING]</b>
                        }
                        @if(version.AIBreaking == true)
                        {
                            <b class="text-danger ms-2">[AI: BREAKING]</b>
                        }
                        @if(version.IsSuspectedMalicious == true)
                        {
                            <b class="text-danger ms-2">[POSSIBLE MALICIOUS]</b>
                        }
                        @if(version.Ignored)
                        {
                            <span class="badge bg-secondary ms-2">Ignored</span>
                        } else {
                            <button class="btn btn-outline-primary" @onclick="async () => await ToggleIgnoreVersion(version)">Ignore this version</button>
                        }
                        @if(_selectedVersion?.Id == version.Id)
                        {
                            <span class="badge bg-success ms-2">Selected for Update</span>
                        }
                        else
                        {
                            <button class="btn btn-outline-success ms-2" @onclick="async () => await SetTargetVersion(version)">Select for Update</button>
                        }
                    </div>
                    @if (!string.IsNullOrWhiteSpace(version.SecurityAnalysis))
                    {
                        <div class="alert alert-warning mb-2 mt-2"><b>Security Analysis:</b> @version.SecurityAnalysis</div>
                    }
                    @if (!string.IsNullOrWhiteSpace(version.AISummary))
                    {
                        <div class="alert alert-info mb-2 mt-2"><b>AI Summary:</b> @version.AISummary</div>
                        <details>
                            <summary>Full release notes</summary>
                            <div>@(version.Body.ToMarkupString())</div>
                        </details>
                    } else
                    {
                        <div>@(version.Body.ToMarkupString())</div>
                    }
                </li>
            }
        </ul>

        @if (_updatePlan is not null || processingUpdate is not null)
        {
            @if(processingUpdate is null && _updatePlan?.Steps is not null) 
            {
                <div class="alert alert-info" role="alert">
                    An update is available for this app!
                </div>

                <ul>
                    @foreach(var step in _updatePlan.Steps)
                    {
                        <li>
                            @step
                        </li>
                    }
                </ul>
            } else if (_updatePlan?.FailReason is not null)
            {
                <div class="alert alert-danger" role="alert">
                    No valid update plan could be generated for this update for reason: @_updatePlan.FailReason<br/>
                    Please check the logs, make sure you're running on a specific version image (e.g. v1.5.0) as latest, stable, etc. are not supported yet.<br/>
                    Furthermore, make sure either the compose file or the .env file contains the text of the version.<br/>
                    If you cannot figure out the reason for why a plan could not be generated, open up an issue on GitHub.
                </div>
            }

            <button class="btn btn-primary" @onclick="ExecuteUpdate" disabled="@(_jobRegistry.GetQueuedUpdateForContainer(_app.Id) is not null || processingUpdate is not null)">
                @if (processingUpdate is not null)
                {
                    <span class="spinner-grow spinner-grow-sm" aria-hidden="true"></span>
                }
                else if (_jobRegistry.GetQueuedUpdateForContainer(_app.Id) is not null)
                {
                    <span class="material-symbols-outlined" aria-hidden="true">schedule</span>
                    <span>Queued</span>
                }
                else
                {
                    <span>Update Now</span>
                }
            </button>

            @if (processingUpdate is not null)
            {
                <div class="mb-4 mt-4">
                    <h5>Update Progress:</h5>
                    <Terminal @ref=_terminal />
                </div>
            }
        }
    }
}


@code {
    [Parameter]
    public required int ContainerId { get; set; }

    private Container? _app;
    private UpdatePlanModel? _updatePlan;
    private Terminal _terminal = default!;
    private AppVersion? _selectedVersion;
    private System.Timers.Timer? _pollTimer;
    private readonly CancellationTokenSource _cts = new();
    private long? _currentJobSequence;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
            return;

        await LoadData();
    }

    private async Task LoadData()
    {
        await using var db = await _dbContextFactory.CreateDbContextAsync();

        var app = await db.Containers.Include(x => x.MultiContainerApp).ThenInclude(x => x!.Containers).Include(x => x.NewerVersions).FirstAsync(a => a.Id == ContainerId);

        app.NewerVersions.Sort((x, y) => VersionHelper.NewerComparison(x.VersionNumber, y.VersionNumber));

        if (app.NewerVersions.Any())
        {
            if (_updateService.IsUpdateAvailable(app))
            {
                _selectedVersion ??= app.NewerVersions.First();
                _updatePlan = await _updateService.Update(app, true, _selectedVersion);
            }
        }
        _app = app;

        if (_jobRegistry.GetQueuedUpdateForContainer(_app.Id) is not null || _jobRegistry.GetProcessingUpdateForContainer(_app.Id) is not null)
        {
            StartPolling();
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task SetTargetVersion(AppVersion version)
    {
        _selectedVersion = version;

        if (_app is not null && _updateService.IsUpdateAvailable(_app))
        {
            _updatePlan = await _updateService.Update(_app, true, _selectedVersion);
            StateHasChanged();
        }
    }

    private async Task ExecuteUpdate()
    {
        ArgumentNullException.ThrowIfNull(_app);
        ArgumentNullException.ThrowIfNull(_selectedVersion);

        await _jobRegistry.MarkForUpdate(_app.Id, _selectedVersion.Id, _selectedVersion.VersionNumber);

        StateHasChanged();

        StartPolling();
    }

    private void StartPolling()
    {
        if (_pollTimer is not null)
            return;

        _pollTimer = new(1000);
        _pollTimer.Elapsed += async (_, __) => await PollOutput();
        _pollTimer.AutoReset = true;
        _pollTimer.Start();
    }

    private async Task PollOutput()
    {
        ArgumentNullException.ThrowIfNull(_app);

        if(_cts.IsCancellationRequested || _terminal is null)
            return;

        await InvokeAsync(StateHasChanged);

        if(_currentJobSequence is null) 
        {
            _currentJobSequence = _jobRegistry.GetProcessingUpdateForContainer(_app.Id) ?? _jobRegistry.GetQueuedUpdateForContainer(_app.Id);
        }

        if(_currentJobSequence is null) 
            return;

        var output = _jobRegistry.GetOutputSnapshot(_currentJobSequence.Value);

        foreach (var line in output)
        {
            await _terminal.NewLine(line);
        }

        if (_jobRegistry.GetQueuedUpdateForContainer(_app.Id) is null && _jobRegistry.GetProcessingUpdateForContainer(_app.Id) is null)
        {
            DisposeTimer();
            _selectedVersion = null;
            await LoadData();
        }
    }

    private async Task ToggleIgnoreVersion(AppVersion version)
    {
        await using var db = await _dbContextFactory.CreateDbContextAsync();

        version.Ignored = !version.Ignored;
        await db.AppVersions.Where(x => x.Id == version.Id).ExecuteUpdateAsync(x => x.SetProperty(setter => setter.Ignored, version.Ignored));
    }

    private void DisposeTimer() 
    {
        if (_pollTimer is not null)
        {
            _pollTimer.Stop();
            _pollTimer.Dispose();
            _pollTimer = null;
        }
    }

    public void Dispose()
    {
        _cts.Cancel();
        _cts.Dispose();
        DisposeTimer();
    }
}
